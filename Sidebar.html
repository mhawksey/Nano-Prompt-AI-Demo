<!DOCTYPE html>
<html>

<head>
  <base target="_top">
  <link rel="stylesheet" href="https://ssl.gstatic.com/docs/script/css/styles.css">
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 10px;
    }

    textarea {
      width: 98%;
      margin-bottom: 10px;
      border: 1px solid #ccc;
      padding: 5px;
    }

    button {
      margin-right: 5px;
      margin-bottom: 10px;
    }

    #mermaid-diagram {
      margin-top: 10px;
      padding: 10px;
      border: 1px solid #eee;
      min-height: 100px;
      text-align: center;
    }

    #error-message {
      color: red;
      margin-top: 10px;
    }

    #fix-button-container {
      margin-top: 5px;
    }

    label {
      font-weight: bold;
      margin-bottom: 3px;
      display: block;
    }

    .input-group {
      margin-bottom: 10px;
      display: flex;
      align-items: center;
    }

    .input-group label {
      margin-right: 5px;
      margin-bottom: 0;
    }

    .input-group input[type="number"] {
      width: 70px;
    }

    #image-preview {
      max-width: 98%;
      max-height: 200px;
      margin-top: 5px;
      margin-bottom: 10px;
      border: 1px solid #ddd;
      display: none; /* Hidden by default */
    }
    .input-section {
        margin-bottom: 15px;
        padding-bottom: 10px;
        border-bottom: 1px solid #eee;
    }
    .input-section:last-child {
        border-bottom: none;
    }
  </style>
</head>

<body>
  <div id="error-message"></div>
  <div id="fix-button-container">
    <button id="fix-diagram-btn" onclick="fixDiagramWithAI()" style="display:none; background-color: #ffae42; color: black;">Fix Diagram with AI</button>
  </div>
  <div id="info-message" style="color:blue;"></div>

  <div class="input-section">
    <label for="prompt-input">Describe your diagram (AI will generate Mermaid code):</label>
    <textarea id="prompt-input" rows="4" placeholder="e.g., A simple flow chart with a start, a process, and an end."></textarea>
    <button id="generate-from-prompt-btn" onclick="generateFromPrompt()">Generate Diagram from Description</button>
  </div>

  <div class="input-section">
    <label for="image-upload-input">Or upload an image/sketch of your diagram:</label>
    <input type="file" id="image-upload-input" accept="image/*" onchange="previewImage(event)">
    <img id="image-preview" src="#" alt="Image Preview"/>
    <button id="generate-from-image-btn" onclick="generateFromImage()">Generate Diagram from Image</button>
  </div>

  <hr>

  <div>
    <label for="mermaid-code">MermaidJS Code:</label>
    <textarea id="mermaid-code" rows="10" placeholder="graph TD&#10;    A[Start] --> B(Process);&#10;    B --> C{Decision};&#10;    C -->|Yes| D[End];&#10;    C -->|No| E[Something Else];"></textarea>
    <button onclick="renderDiagram()">Render Diagram from Code</button>
    <div class="input-group">
      <label for="image-width">Width (px):</label>
      <input type="number" id="image-width" placeholder="1200" style="width: 80px; margin-right:10px;">
      <button id="insert-diagram-btn" onclick="insertDiagram()">Insert Diagram into Document</button>
    </div>
  </div>

  <label>Preview:</label>
  <div id="mermaid-diagram">
  </div>

  <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
  <script>
    let languageModelSession;
    let mermaidInitialized = false;
    let currentMermaidError = '';
    let uploadedImageFile = null;

    let globalTemperature = 0.3;
    let globalTopK = 1;

    // --- System Prompts ---
    // Using the original system prompt for text-to-MermaidJS as a base.
    // The multimodal model should adapt if an image is also provided.
    const systemPromptForDiagramGeneration = `You are an expert in MermaidJS. Convert the user's natural language description or the concepts depicted in an uploaded image into valid MermaidJS markdown code. Output ONLY the MermaidJS code block itself. Do NOT include any explanatory text, greetings, apologies, or markdown fences like \\\`\\\`\\\`mermaid or \\\`\\\`\\\`. Your entire response should be directly usable as MermaidJS code.
Here's a condensed reference for Mermaid flowchart syntax:\n\n**Flowchart Syntax Reference:**\n\n---\n\nFlowcharts are composed of **nodes** (geometric shapes) and **edges** (arrows or lines).\n\n### **Node Definition**\n\nNodes are defined by an id and text. The id is for internal reference, and the text is what is displayed in the flowchart.\n\n### **A node with text**\n\nIt is also possible to set text in the box that differs from the id. If this is done several times, it is the last text found for the node that will be used. Also if you define edges for the node later on, you can omit text definitions. The one previously defined will be used when rendering the box.\n\n\\\`\\\`\\\`\n---\ntitle: Node with text\n---\nflowchart LR\n    id1[This is the text in the box]\n\\\`\\\`\\\`\n\n#### **Unicode text**\n\nUse \`"\` to enclose the unicode text.\n\n\\\`\\\`\\\`\nflowchart LR\n    id["This 笶､ Unicode"]\n\\\`\\\`\\\`\n\n#### **Markdown formatting**\n\nUse double quotes and backticks "\\\` text \\\`" to enclose the markdown text.\n\n\\\`\\\`\\\`\n---\nconfig:\n  flowchart:\n    htmlLabels: false\n---\nflowchart LR\n    markdown["\\\`This **is** _Markdown_\\\`"]\n    newLines["\\\`Line1\n    Line 2\n    Line 3\\\`"]\n    markdown --> newLines\n\\\`\\\`\\\`\n\n### **Node Shapes**\n\n* **Round edges**: id(text)  \n* **Stadium**: id(\\[text\\])  \n* **Subroutine**: id\\[\\[text\\]\\]  \n* **Cylindrical (Database)**: id\\[(text)\\]  \n* **Circle**: id((text))  \n* **Asymmetric**: id\\>text\\]  \n* **Rhombus (Decision)**: id{text}  \n* **Hexagon**: id{{text}}  \n* **Parallelogram**: id\\[/text/\\]  \n* **Parallelogram Alt**: id\\[\\\\text\\\\\\]  \n* **Trapezoid**: id\\[/text\\\\\\]  \n* **Trapezoid Alt**: id\\[\\\\text/\\]  \n* **Double Circle**: id(((text)))\n\n### **Flowchart Direction**\n\nDeclare the direction of the flowchart:\n\n* flowchart TD (Top to bottom) or flowchart TB  \n* flowchart LR (Left to right)  \n* flowchart BT (Bottom to top)  \n* flowchart RL (Right to left)\n\n### **Links Between Nodes**\n\nNodes are connected with links (edges).\n\n* **Arrow head**: A--\\>B  \n* **Open link**: A --- B  \n* **Text on links**: A-- text ---B or A---|text|B  \n* **Arrow head and text**: A--\\>|text|B or A-- text --\\>B  \n* **Dotted link**: A-.- \\>B  \n* **Dotted link with text**: A-. text .-\\> B  \n* **Thick link**: A ==\\> B  \n* **Thick link with text**: A == text ==\\> B  \n* **Invisible link**: A ~~~ B  \n* **Chaining links**: A -- text --\\> B -- text2 --\\> C or a --\\> b & c--\\> d  \n* **Multi-node links**: A & B--\\> C & D  \n* **Attaching ID to Edges**: A e1@--\\> B. Use e1@{ animate: true } or e1@{ animation: fast } for animations.  \n* **New arrow types**:  \n  * Circle edge: A --o B  \n  * Cross edge: A --x B  \n* **Multi-directional arrows**: A o--o B, B <--> C, C x--x D  \n* **Minimum link length**: Add extra dashes (-, =, .) to links. A ----\\> E makes the link longer.\n\n### **Special Characters**\n\nEnclose text in quotes for problematic characters: id1["This is the (text) in the box"].  \nUse entity codes: A["A double quote:\\#quot;"].\n\n### **Subgraphs**\n\nGroup nodes into subgraphs:\n\nsubgraph title  \n    graph definition  \nend\n\nEdges can connect to and from subgraphs. Subgraphs can also have their own direction statement. However, if any of a subgraph's nodes are linked externally, the subgraph's direction is ignored.\n\n### **Comments**\n\nComments can be entered within a flow diagram, which will be ignored by the parser. Comments need to be on their own line, and must be prefaced with \`%%\` (double percent signs). Any text after the start of the comment to the next newline will be treated as a comment, including any flow syntax\n\n\\\`\\\`\\\`\nflowchart LR\n%% this is a comment A -- text --> B{node}\n   A -- text --> B -- text2 --> C\n\\\`\\\`\\\`\n\n### **Configuration**\n\n* **Renderer**: defaultRenderer: "elk" for the elk renderer (v9.4+).  \n* **Width**: Set mermaid.flowchartConfig = { width: 100% }\n\n**Examples (for text input):**\n\n**User Input:** Create a flowchart that starts with "Begin" (rounded edges), then goes to "Decision Point" (rhombus) with two paths: "Yes" leading to "Process A", and "No" leading to "Process B". Both Process A and Process B then connect to an "End" node (stadium shape). The flowchart should flow from top to bottom.\n\n**Expected Output:**\n\nflowchart TD\n    A(Begin)\n    B{Decision Point}\n    C[Process A]\n    D[Process B]\n    E([End])\n\n    A --> B\n    B -- Yes --> C\n    B -- No --> D\n    C --> E\n    D --> E\n\n**Example (for image input):**\nIf an image depicts a simple sequence: Object A points to Object B, which points to Object C.\n**Expected Output (conceptual):**\nflowchart LR\n    A --> B\n    B --> C\n`;
    // --- End System Prompts ---


    function previewImage(event) {
      const reader = new FileReader();
      const imagePreview = document.getElementById('image-preview');
      reader.onload = function(){
        imagePreview.src = reader.result;
        imagePreview.style.display = 'block';
      }
      if (event.target.files[0]) {
        uploadedImageFile = event.target.files[0];
        reader.readAsDataURL(event.target.files[0]);
      } else {
        uploadedImageFile = null;
        imagePreview.src = '#';
        imagePreview.style.display = 'none';
      }
    }

    function initializeMermaid() {
      if (!mermaidInitialized) {
        try {
          mermaid.initialize({
            startOnLoad: false,
          });
          mermaidInitialized = true;
          console.log("Mermaid initialized.");
        } catch (e) {
          console.error("Mermaid initialization failed:", e);
          document.getElementById('error-message').textContent = "Mermaid library failed to initialize: " + e.message;
        }
      }
    }

    async function initializeLanguageModel() {
      const promptButton = document.getElementById('generate-from-prompt-btn');
      const imageButton = document.getElementById('generate-from-image-btn');
      const errorMessageDiv = document.getElementById('error-message');
      const infoMessageDiv = document.getElementById('info-message');

      if (typeof LanguageModel === "undefined") {
        errorMessageDiv.textContent = 'Built-in AI (LanguageModel API) is not available in this browser. You can still manually enter Mermaid code.';
        console.warn('LanguageModel API not available.');
        if (promptButton) promptButton.disabled = true;
        if (imageButton) imageButton.disabled = true;
        return false;
      }

      try {
        // Initialize for multimodal to support images. This session should also handle text.
        const availability = await LanguageModel.availability({expectedInputs:[{type:'image'}]});
        if (availability !== "available" && infoMessageDiv.textContent.indexOf('download') === -1) {
            infoMessageDiv.textContent = `AI Model Status: ${availability}`;
        }

        if (availability === "unavailable") {
          errorMessageDiv.textContent = 'AI features are unavailable on this device. Manual code entry is still available.';
          if (promptButton) promptButton.disabled = true;
          if (imageButton) imageButton.disabled = true;
          return false;
        }

        if (availability === "downloadable" || availability === "downloading") {
          if (infoMessageDiv.textContent.indexOf('download progress') === -1) {
             infoMessageDiv.textContent = "AI model is downloading or needs to be downloaded. Please wait... Initialization might take a moment.";
          }
        }

        if (languageModelSession) {
            try {
                const currentQuota = await languageModelSession.inputQuota;
                 if (currentQuota > 0) {
                    console.log("LanguageModel session already exists and seems valid.");
                    if (infoMessageDiv.textContent.indexOf('download') === -1 && infoMessageDiv.textContent.indexOf('AI is ready') === -1) {
                         infoMessageDiv.textContent = "AI is ready.";
                    }
                    if (promptButton) promptButton.disabled = false;
                    if (imageButton) imageButton.disabled = false;
                    return true;
                 }
            } catch (e) {
                console.warn("Error checking existing session quota, will reinitialize:", e);
                languageModelSession = null;
            }
        }

        const sessionOptions = {
          expectedInputs:[{type: 'image'}], // Critical for image support
          initialPrompts: [{
            role: "system",
            content: systemPromptForDiagramGeneration
          }],
          monitor(m) {
            m.addEventListener("downloadprogress", e => {
              const progress = e.total ? Math.round(e.loaded / e.total * 100) : e.loaded; // Handle cases where total might be 0
              infoMessageDiv.textContent = `AI model download progress: ${progress}%`;
              console.log(`AI Model Downloaded ${progress}%`);
            });
          }
        };

        if (globalTemperature !== undefined) {
          sessionOptions.temperature = globalTemperature;
          console.log(`Using globalTemperature: ${globalTemperature}`);
        }
        if (globalTopK !== undefined) {
          sessionOptions.topK = globalTopK;
          console.log(`Using globalTopK: ${globalTopK}`);
        }

        languageModelSession = await LanguageModel.create(sessionOptions);
        console.log("LanguageModel session created successfully (multimodal ready).");
        infoMessageDiv.textContent = "AI is ready. Describe your diagram or upload an image!";
        if (promptButton) promptButton.disabled = false;
        if (imageButton) imageButton.disabled = false;
        return true;

      } catch (error) {
        console.error("Failed to initialize LanguageModel session:", error);
        errorMessageDiv.textContent = 'Error initializing AI: ' + error.message + '. Manual code entry is still available.';
        if (promptButton) promptButton.disabled = true;
        if (imageButton) imageButton.disabled = true;
        return false;
      }
    }

    async function generateFromPrompt() {
      const promptInputText = document.getElementById('prompt-input').value;
      const mermaidCodeTextarea = document.getElementById('mermaid-code');
      const errorMessageDiv = document.getElementById('error-message');
      const infoMessageDiv = document.getElementById('info-message');
      const promptButton = document.getElementById('generate-from-prompt-btn');

      errorMessageDiv.textContent = '';
      infoMessageDiv.textContent = '';
      document.getElementById('fix-diagram-btn').style.display = 'none';

      if (!promptInputText.trim()) {
        errorMessageDiv.textContent = 'Please enter a description for the diagram.';
        return;
      }

      if (!languageModelSession) {
        infoMessageDiv.textContent = 'AI session not initialized. Attempting to initialize...';
        const initialized = await initializeLanguageModel();
        if (!initialized || !languageModelSession) {
           errorMessageDiv.textContent = 'AI session could not be initialized. Please ensure your browser supports built-in AI and try reloading. Manual code entry is still available.';
           return;
        }
        infoMessageDiv.textContent = 'AI initialized. Please try generating again.';
      }

      promptButton.disabled = true;
      promptButton.textContent = 'Generating...';
      infoMessageDiv.textContent = 'AI is thinking...';

      try {
        // For text prompt, we just send the text.
        // The session was initialized to handle images, but should also process text-only prompts.
        const result = await languageModelSession.prompt(promptInputText);
        console.log("Raw AI Response (Generate from Prompt):", result);

        let finalCode = result.trim();
        const mermaidBlockRegex = /```(?:mermaid)?\s*([\s\S]*?)\s*```/;
        const match = mermaidBlockRegex.exec(finalCode);

        if (match && match[1]) {
          finalCode = match[1].trim();
          console.log("Extracted from markdown block (Generate from Prompt):", finalCode);
        } else {
            console.log("Using direct AI response (Generate from Prompt, assuming raw code):", finalCode);
        }

        const validStartRegex = /^(graph|flowchart|sequenceDiagram|classDiagram|stateDiagram|erDiagram|journey|gantt|pie|mindmap|timeline|C4Context|C4Container|C4Component|C4Dynamic|C4Deployment)/i;
        if (!validStartRegex.test(finalCode.substring(0,100))) {
            console.warn("AI output (from prompt) might not be valid MermaidJS code.", finalCode);
            infoMessageDiv.textContent = "AI response (from prompt) might not be valid Mermaid code. Please check the output.";
        }

        mermaidCodeTextarea.value = finalCode;
        renderDiagram();
        if (!document.getElementById('error-message').textContent.includes("Mermaid syntax error")) {
            infoMessageDiv.textContent = 'Diagram code generated from description!';
        }
      } catch (error) {
        console.error("Error prompting LanguageModel (Generate from Prompt):", error);
        let errorDetail = error.message;
        if (error.name === 'QuotaExceededError') {
            errorDetail = `The diagram description might be too long or complex for the AI. (Quota: ${error.quota}, Requested: ${error.requested})`;
        }
        mermaidCodeTextarea.value = `%% Error generating diagram from prompt: ${errorDetail}\n%% Please check your description or try again.\n\n${mermaidCodeTextarea.value}`;
        errorMessageDiv.textContent = 'Error generating diagram from prompt: ' + errorDetail;
        renderDiagram();
      } finally {
        promptButton.disabled = false;
        promptButton.textContent = 'Generate Diagram from Description';
      }
    }


    async function generateFromImage() {
      const mermaidCodeTextarea = document.getElementById('mermaid-code');
      const errorMessageDiv = document.getElementById('error-message');
      const infoMessageDiv = document.getElementById('info-message');
      const imageButton = document.getElementById('generate-from-image-btn');

      errorMessageDiv.textContent = '';
      infoMessageDiv.textContent = '';
      document.getElementById('fix-diagram-btn').style.display = 'none';

      if (!uploadedImageFile) {
        errorMessageDiv.textContent = 'Please upload an image file first.';
        return;
      }

      if (!languageModelSession) {
        infoMessageDiv.textContent = 'AI session not initialized. Attempting to initialize...';
        const initialized = await initializeLanguageModel();
        if (!initialized || !languageModelSession) {
           errorMessageDiv.textContent = 'AI session could not be initialized. Please ensure your browser supports built-in AI and try reloading. Manual code entry is still available.';
           return;
        }
        infoMessageDiv.textContent = 'AI initialized. Please try generating again.';
      }

      imageButton.disabled = true;
      imageButton.textContent = 'Generating...';
      infoMessageDiv.textContent = 'AI is analyzing the image...';

      try {
        const imageBitmap = await createImageBitmap(uploadedImageFile);
        // Prompt array for multimodal input
        const result = await languageModelSession.prompt([
          'Analyze the provided image and represent its structure or flow as MermaidJS code.', // Text part of the prompt
          { type: "image", content: imageBitmap } // Image part of the prompt
        ]);
        console.log("Raw AI Response (Generate from Image):", result);

        let finalCode = result.trim();
        const mermaidBlockRegex = /```(?:mermaid)?\s*([\s\S]*?)\s*```/;
        const match = mermaidBlockRegex.exec(finalCode);

        if (match && match[1]) {
          finalCode = match[1].trim();
          console.log("Extracted from markdown block (Generate from Image):", finalCode);
        } else {
            console.log("Using direct AI response (Generate from Image, assuming raw code):", finalCode);
        }

        const validStartRegex = /^(graph|flowchart|sequenceDiagram|classDiagram|stateDiagram|erDiagram|journey|gantt|pie|mindmap|timeline|C4Context|C4Container|C4Component|C4Dynamic|C4Deployment)/i;
        if (!validStartRegex.test(finalCode.substring(0,100))) {
            console.warn("AI output (from image) might not be valid MermaidJS code.", finalCode);
            infoMessageDiv.textContent = "AI response (from image) might not be valid Mermaid code. Please check the output.";
        }

        mermaidCodeTextarea.value = finalCode;
        renderDiagram();
        if (!document.getElementById('error-message').textContent.includes("Mermaid syntax error")) {
            infoMessageDiv.textContent = 'Diagram code generated from image!';
        }
      } catch (error) {
        console.error("Error prompting LanguageModel (Generate from Image):", error);
        let errorDetail = error.message;
        if (error.name === 'QuotaExceededError') {
            errorDetail = `The image or request might be too complex for the AI. (Quota: ${error.quota}, Requested: ${error.requested})`;
        }
        mermaidCodeTextarea.value = `%% Error generating diagram from image: ${errorDetail}\n%% Please try a different image or check the AI model status.\n\n${mermaidCodeTextarea.value}`;
        errorMessageDiv.textContent = 'Error generating diagram from image: ' + errorDetail;
        renderDiagram();
      } finally {
        imageButton.disabled = false;
        imageButton.textContent = 'Generate Diagram from Image';
      }
    }

    async function fixDiagramWithAI() {
      const mermaidCodeTextarea = document.getElementById('mermaid-code');
      const currentCode = mermaidCodeTextarea.value;
      const errorMessageDiv = document.getElementById('error-message');
      const infoMessageDiv = document.getElementById('info-message');
      const fixButton = document.getElementById('fix-diagram-btn');

      if (!currentMermaidError) {
        infoMessageDiv.textContent = 'No rendering error detected to fix.';
        return;
      }
      if (!currentCode.trim()) {
        infoMessageDiv.textContent = 'No code to fix.';
        return;
      }

      if (!languageModelSession) {
        infoMessageDiv.textContent = 'AI session not initialized. Attempting to initialize...';
        const initialized = await initializeLanguageModel();
        if (!initialized || !languageModelSession) {
           errorMessageDiv.textContent = 'AI session could not be initialized for fixing.';
           return;
        }
        infoMessageDiv.textContent = 'AI initialized. Retrying fix...';
      }

      fixButton.disabled = true;
      fixButton.textContent = 'AI Fixing...';
      infoMessageDiv.textContent = 'AI is attempting to fix the diagram...';
      errorMessageDiv.textContent = '';

      const fixPrompt = `The following MermaidJS code produced an error.
Error message: "${currentMermaidError}"

Original problematic MermaidJS code:
\`\`\`mermaid
${currentCode}
\`\`\`
Please analyze the error and the code, then provide a corrected version of ONLY the MermaidJS code block itself. Do NOT include any explanatory text, greetings, apologies, or markdown fences like \`\`\`mermaid or \`\`\`. Your entire response should be directly usable as MermaidJS code. Ensure the output starts directly with a valid Mermaid diagram type like 'graph TD', 'sequenceDiagram', etc.`;

      try {
        const result = await languageModelSession.prompt(fixPrompt);
        console.log("Raw AI Response (Fix):", result);

        let fixedCode = result.trim();
        const mermaidBlockRegex = /```(?:mermaid)?\s*([\s\S]*?)\s*```/;
        const match = mermaidBlockRegex.exec(fixedCode);

        if (match && match[1]) {
          fixedCode = match[1].trim();
          console.log("Extracted from markdown block (Fix):", fixedCode);
        } else {
          console.log("Using direct AI response (Fix, assuming raw code):", fixedCode);
        }

        mermaidCodeTextarea.value = fixedCode;
        infoMessageDiv.textContent = 'AI provided a fix. Attempting to render...';
        await renderDiagram();

        if (!document.getElementById('error-message').textContent.includes("Mermaid syntax error")) {
             infoMessageDiv.textContent = 'AI fix applied and rendered successfully!';
             fixButton.style.display = 'none';
             currentMermaidError = '';
        } else {
            infoMessageDiv.textContent = 'AI tried to fix, but there might still be an issue. See error below.';
        }

      } catch (error) {
        console.error("Error prompting LanguageModel (Fix):", error);
        let errorDetail = error.message;
        if (error.name === 'QuotaExceededError') {
            errorDetail = `The code/error message might be too long for the AI to process for a fix. (Quota: ${error.quota}, Requested: ${error.requested})`;
        }
        errorMessageDiv.textContent = 'Error asking AI to fix diagram: ' + errorDetail;
        await renderDiagram();
      } finally {
        fixButton.disabled = false;
        fixButton.textContent = 'Fix Diagram with AI';
      }
    }

    async function renderDiagram() {
      initializeMermaid();
      if (!mermaidInitialized) return;

      const mermaidCode = document.getElementById('mermaid-code').value;
      const mermaidDiagramDiv = document.getElementById('mermaid-diagram');
      const errorMessageDiv = document.getElementById('error-message');
      const fixButton = document.getElementById('fix-diagram-btn');

      if (errorMessageDiv.textContent.startsWith("Mermaid syntax error") || errorMessageDiv.textContent.startsWith("Error rendering diagram")) {
          errorMessageDiv.textContent = '';
      }
      mermaidDiagramDiv.innerHTML = '';
      fixButton.style.display = 'none';
      currentMermaidError = '';

      if (!mermaidCode.trim()) {
        mermaidDiagramDiv.innerHTML = '<em>Preview will appear here. Describe, upload, or enter code.</em>';
        return;
      }

      try {
        const { svg, bindFunctions } = await mermaid.render('renderedMermaidDiagram', mermaidCode);
        mermaidDiagramDiv.innerHTML = svg;
        if (bindFunctions) {
            bindFunctions(mermaidDiagramDiv);
        }
        if (errorMessageDiv.textContent.startsWith("Mermaid syntax error") || errorMessageDiv.textContent.startsWith("Error rendering diagram")) {
            errorMessageDiv.textContent = '';
        }
        fixButton.style.display = 'none';
        currentMermaidError = '';
        console.log("Mermaid diagram rendered successfully.");
      } catch (error) {
        console.error("Mermaid rendering error:", error);
        currentMermaidError = error.message;
        errorMessageDiv.textContent = "Mermaid syntax error or rendering issue: " + currentMermaidError;
        mermaidDiagramDiv.innerHTML = `<pre style="color:red;">Error rendering diagram:\n${error.message}\n\nYour code:\n${mermaidCode.replace(/</g, "&lt;").replace(/>/g, "&gt;")}</pre>`;
        if (typeof LanguageModel !== "undefined" && languageModelSession) {
            fixButton.style.display = 'inline-block';
        }
      }
    }

    function svgToPngDataURL(svgString, targetWidth, callback) {
      const errorMessageDiv = document.getElementById('error-message');
      if (!svgString || typeof svgString !== 'string' || !svgString.startsWith('<svg')) {
          console.error("Invalid SVG string passed to svgToPngDataURL:", svgString);
          if (errorMessageDiv) errorMessageDiv.textContent = "Error: Invalid SVG data for conversion.";
          callback(null);
          return;
      }

      const img = new Image();
      const svgDataUri = 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(svgString)));

      img.onload = () => {
        if (img.width === 0 || img.height === 0) {
           console.error("SVG loaded with zero dimensions. Cannot convert to PNG.");
           if (errorMessageDiv) errorMessageDiv.textContent = "Error: SVG has zero dimensions, cannot process for PNG conversion.";
           callback(null);
           return;
        }

        const canvas = document.createElement('canvas');
        const originalWidth = img.width;
        const originalHeight = img.height;

        canvas.width = targetWidth;
        canvas.height = originalHeight * (targetWidth / originalWidth);

        const ctx = canvas.getContext('2d');
        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

        try {
          const pngDataUrl = canvas.toDataURL('image/png');
          callback(pngDataUrl);
        } catch (e) {
           console.error("Error converting canvas to PNG Data URL:", e);
           if (errorMessageDiv) {
               errorMessageDiv.textContent = "Error converting to PNG: " + e.message;
               if (e.name === "SecurityError") {
                   errorMessageDiv.textContent = "Error: Canvas security error during PNG conversion. This can happen with tainted canvases (e.g. external images in SVG).";
               }
           }
           callback(null);
        }
      };

      img.onerror = (e) => {
        console.error("Error loading SVG Data URI into Image object:", e);
        if (errorMessageDiv) errorMessageDiv.textContent = "Error: Failed to load the generated SVG into an image object for PNG conversion.";
        callback(null);
      };

      img.src = svgDataUri;
    }

    function insertDiagram() {
      const mermaidDiagramDiv = document.getElementById('mermaid-diagram');
      const errorMessageDiv = document.getElementById('error-message');
      const infoMessageDiv = document.getElementById('info-message');
      const widthInput = document.getElementById('image-width');
      const insertButton = document.getElementById('insert-diagram-btn');

      errorMessageDiv.textContent = '';
      infoMessageDiv.textContent = '';

      const svgElement = mermaidDiagramDiv.querySelector('svg');

      if (!svgElement) {
        errorMessageDiv.textContent = 'No diagram rendered to insert. Please generate or enter code and render first.';
        console.log('No SVG found to insert.');
        return;
      }

      if (!svgElement.getAttribute('xmlns')) {
          svgElement.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
      }
      const svgString = svgElement.outerHTML;

      let exportWidth;
      const widthValue = widthInput.value.trim();

      if (widthValue === '') {
          exportWidth = 1200;
      } else {
          exportWidth = parseInt(widthValue, 10);
          if (isNaN(exportWidth) || exportWidth <= 0) {
              errorMessageDiv.textContent = 'Please enter a valid positive number for the export width (e.g., 1200), or leave it empty for the default (1200px).';
              console.error('Invalid export width for PNG:', widthValue);
              return;
          }
      }

      if (insertButton) {
        insertButton.disabled = true;
        insertButton.textContent = 'Processing...';
      }
      infoMessageDiv.textContent = 'Converting diagram to PNG...';

      svgToPngDataURL(svgString, exportWidth, (pngDataUrl) => {
        if (!pngDataUrl) {
          if (!errorMessageDiv.textContent) {
              errorMessageDiv.textContent = 'Error: Failed to convert diagram to PNG.';
          }
          infoMessageDiv.textContent = '';
          if (insertButton) {
            insertButton.disabled = false;
            insertButton.textContent = 'Insert Diagram into Document';
          }
          return;
        }

        const base64ImageData = pngDataUrl.substring(pngDataUrl.indexOf(',') + 1);
        infoMessageDiv.textContent = 'Inserting PNG into document...';

        google.script.run
          .withSuccessHandler(() => {
            console.log('Diagram inserted successfully via Apps Script.');
            infoMessageDiv.textContent = 'Diagram inserted successfully!';
            if (insertButton) {
              insertButton.disabled = false;
              insertButton.textContent = 'Insert Diagram into Document';
            }
          })
          .withFailureHandler((err) => {
            console.error('Error inserting diagram via Apps Script:', err);
            errorMessageDiv.textContent = 'Error inserting diagram: ' + (err.message || JSON.stringify(err));
            infoMessageDiv.textContent = '';
            if (insertButton) {
              insertButton.disabled = false;
              insertButton.textContent = 'Insert Diagram into Document';
            }
          })
          .insertMermaidImage(base64ImageData);
      });
    }

    window.onload = async () => {
      initializeMermaid();
      document.getElementById('image-width').placeholder = "1200 (default)";

      const aiInitialized = await initializeLanguageModel();
      if (aiInitialized && !document.getElementById('info-message').textContent.includes('download')) {
          document.getElementById('info-message').textContent = "AI initialized. Describe, upload, or enter code.";
      } else if (!aiInitialized && !document.getElementById('error-message').textContent) {
          if (!document.getElementById('info-message').textContent) {
             document.getElementById('info-message').textContent = "Manual Mermaid code entry is available. AI features might be unavailable or downloading.";
          }
      }

      if (!document.getElementById('mermaid-code').value.trim()) {
          document.getElementById('mermaid-diagram').innerHTML = '<em>Preview will appear here. Describe, upload, or enter code.</em>';
      } else {
          renderDiagram();
      }
    };
  </script>
</body>

</html>
